# Gitの基本

## Gitインストール（window）
https://gitforwindows.org/ よりインストール（設定は初期でOK）
## Gitの確認
ターミナル（Git Bash）を開く。以下コマンドを入力する。
```
$ git version
```

## gitの初期設定
### Gitの設定ファイルは以下三種類
|設定ファイル  |概要  |
|---|---|
|system  |当該マシンの全ユーザに関する設定  |
|global  |当該ユーザに関する設定  |
|local  |特例のディレクトリ（リポジトリ）に関する設定  |

### 今回はglobalの設定を行うM

```
$ git config --global user.name "github user.name"  //githubのユーザネーム
$ git config --global use.email github@example.com  //githubのメアド
$ git config --global core.editor "atom --wait"     //gitで使うエディタ vs codeなら"code --wait"
```


### 設定の確認
```
$ git config --list
```
個別に見たい場合は`$ git config use.email`のようにする。

### globalのgitconfigの置き場
ログインユーザのHOMEディレクトリ配下の .gitconfig（C:\Users\{username}\.gitconfig）
ターミナルから以下のコマンドでも見れる。
```
$ cat ~/.gitconfig
```

# Gitの基本操作
ローカル（自分のPC）は3つのエリアに分かれている。
- ワークツリー（ファイルを変更する作業場）
- ステージ（コミットの準備をする）
  - git addで変更点をインデックスに保存
- ローカルリポジトリ（スナップショットを記録）
  - git commitでステージのインデックスに保存されているファイルのスナップショットをとる

# Gitのデータ管理
git addやgit commitをすると、ローカルリポジトリに「圧縮ファイル」「ツリーオブファイル」「コミットオファイル」が作成される。
Gitではこれらのファイルを「Gitオブジェクト」と呼び、「.git/object」ディレクトリの下に保存される。
各ファイルの説明は以下のとおりである。

|Gitオブジェクト |概要 |
|---|---|
|圧縮ファイル（blobオブジェクト） |git addをした際にリポジトリに作成される。正確には「blobオブジェクト」と言い、ファイルの中身を圧縮しただけのもの |
|ツリーファイル（treeオブジェクト） |圧縮ファイルには圧縮前の元々のファイル名の情報が入っていない。ファイル名とファイルの中身の組み合わせ（ファイル構造）を保存するためのものがツリーファイルであり、正確には「treeオブジェクト」言う  |
|コミットファイル（commitオブジェクト） |いつ、誰が、何を、何のために、ファイルを変更したのかという情報を保存するもの。正確には「commitオブジェクト」と言う |

## 実際の動きを見てみよう(/・ω・)/
### ローカルリポジトリの作成
ターミナル（Git Bach）を開く。ホームディレクトリへ移動する。

```
$ mkdir sample  //ホームディレクトリ直下に「sampleディレクトリ」を作成
$ cd sample     //sampleディレクトリに移動
$ git init      //現在のディレクトリを（ローカル）リポジトリとして指定する（リポジトリの新規作成）
```

「sampleディレクトリ」内に「.gitディレクトリ」が作成されているのを確認する。隠しファイルなので注意。これが作成されていればローカルリポジトリの作成は成功だょ

### ファイルのステージング
```
$ echo 'Heloo,World!' >hello  //sampleディレクトリ内にhelloファイルを作成
$ git hash-object hello
e965047ad7c57865823c7d992b1d046ea66edf78
```
このような文字列が返ってくる。
返ってきた文字列は「ハッシュID」と言う。ハッシュIDのうち、先頭2文字をディレクトリ名に、その後ろをファイル名にして圧縮ファイルを保存する。
では、実際に圧縮ファイルを作成してみよう。
```
$ git add hello //ファイルをステージングする
```
ここで`.git/object`ディレクトリを確認すると`e9ディレクトリ`内に`65047ad7c57865823c7d992b1d046ea66edf78`という圧縮ファイルが作成されている。先ほどのハッシュIDと同じことを確認しよう。
※ハッシュIDはファイルの中身に対して一意なもの。中身が同じものなら何度`git add`しようとも圧縮ファイルが追加で作られることはない。

### ツリーオブジェクトの確認
ファイルの中身の圧縮ファイルまでは作成出来た。次に元々のファイル名とファイルの中身の組み合わせ（ファイル構造）を保存する。
```
$ git commit -m 'add hello' //コミットしてツリーオブジェクトを作成
[master (root-commit) 41d0cd8] add hello
 1 file changed, 2 insertions(+)
 create mode 100644 hello
$ git cat-file -p master^{tree}  //masterブランチ上での最後のコミットが指しているツリーファイルの中身を表示する。
100644 blob e965047ad7c57865823c7d992b1d046ea66edf78    hello
```

最後のコミットが指しているtreeオブジェクトには、blobオブジェクト「e965047ad7c57865823c7d992b1d046ea66edf78」が「hello」というファイル名だということが保存されている。

### コミットファイルの確認
ツリーファイルが作成されたことで、ファイル構造を追えるようになった。では、いつ、誰が、何を、何のために変更したのかを確認してみる。
```
$ git cat-file -p HEAD  //最新のコミットファイルの中身を表示する
tree 90fa7e05d3e0a8c71be3b43fd1cae61d1b8f6e0a
author eiji-noguchi <github@example.com> 1549210901 +0900
committer eiji-noguchi <github@example.com> 1549210901 +0900

  add hello
```
まず、コミットした時点のtree「90fa7e05d3e0a8c71be3b43fd1cae61d1b8f6e0a」が保存されている。これはこのプロジェクトの一番上のディレクトリのツリーファイルとなる。次に作成者の情報とコミットメッセージが保存されている。
ちなみにこのtreeファイル内を見ると、先ほどのblobオブジェクト確認できる
```
$ git cat-file -p 90fa  //treeファイル中身を確認する
100644 blob e965047ad7c57865823c7d992b1d046ea66edf78    hello
```

### ここまでのまとめ
ここまでファイルの作成からステージング、そしてコミットまでを行ってきた。ここでblobとtreeの関係性をまとめる。
- blob:ファイル
- tree:ディレクトリ
つまり、現在ローカルリポジトリには「90fa7e05d3e0a8c71be3b43fd1cae61d1b8f6e0a」のディレクトリ（tree）下に「e965047ad7c57865823c7d992b1d046ea66edf78」というファイル（blob）が存在しているということ。


### ファイルの変更
最後にファイルを編集し、その変更をコミットした場合の動きを確認してみよう(´・ω・｀)
```
$ vim hello //helloディレクトリを編集し保存する
$ git add hello
$ git commit -m 'update hello'
$ git cat-file -p HEAD  //HEADコマンド：今自分がいるブランチの最新のコミット
tree 9e610c2a62cae34a4d476e1d4eeb3d057a43a339
parent 41d0cd83f6b491c66fd4f009ef77052a5c8d4673
author eiji-noguchi <github@example.com> 1549211186 +0900
committer eiji-noguchi <github@example.com> 1549211186 +0900

  update hello
```

編集したディレクトリをコミットし、再度コミットファイルの中身を確認してみると、`parent`と言う親コミット情報を保存している。Gitはこのように親コミットを保存することによってコミットの履歴を辿れるようにしている。
また、ファイルが変更された場合、変更ファイルやそれらに該当しているtreeのハッシュIDは更新される。

### treeオブジェクトの追加
次にtreeオブジェクトの下に更にtreeオブジェクトを作成する。
```
$ mkdir subdir
$ echo 'Goodbye,world' >subdir/goodbye
$ git add subdir
$ git commit -m 'add goodbye'
[master 79d9920] add goodbye
 1 file changed, 1 insertion(+)
 create mode 100644 subdir/goodbye
$ git cat-file -p HEAD
tree f51ccf26d3de80812e99db8abe654074786b39f0
parent e4f4a712740c385e0da4eefefee96f6ccbe07f2d
author eiji-noguchi <github@example.com> 1549774515 +0900
committer eiji-noguchi <github@example.com> 1549774515 +0900

  add goodbye
$ git cat-file -p master^{tree}
100644 blob c25857953927ed759aa024b43432a278e1fb163d    hello
040000 tree 56e8dcdd51f41264863ffbab155ffea2bc342385    subdir
```

つまりmasterブランチ上のトップにはtree(ディレクトリ)「f51c...」があり、その下にblob(helloファイル)「c258...」とtree(subdirディレクトリ)「56e8...」が存在している。
ここで注意すべきはtreeオブジェクトは自分の直下のファイルやディレクトリしか認識していないこと。先ほど作成した「goodbyeファイル」についてはmasterブランチ上のトップのtree「f51c...」ではなく、その下のtree「56e8...」が認識している。
```
$ git cat-file -p 56e8
100644 blob c90b99c703da8e3bcf6c34a2291bccbb02b6c6bc    goodbye
```
ここで「goodbyeファイル」を編集し、コミットした場合、blob(goodbye)「c90b...」、tree「56e8...」、tree「f51c...」のハッシュIDが変更される。
ちなみにblobやtreeの前についている数字は型である。
- 100644:ファイル
- 040000:ディレクトリ

# GitHub(リモートリポジトリとのやり取り)
##  クローンの作成
GitHubに登録されているプロジェクトからリポジトリのコピーを取得する。
```
$ git clone <リポジトリ名>
```
リモートリポジトリのファイルのコピーがローカルのワークツリーへ、`.git`(リポジトリ)がコピーされる

##  リモートの情報の確認
設定しているリモートリポジトリの情報を表示する。
```
$ git remote
origin
```
この例では`origin`のみリモートに登録されている状態である。
また、対応するURLを表示したい場合は下記コマンドを使用する。
```
$ git remote -v
origin  <URL> (fetch)
origin  <URL> (push)
```
`fetch`と`push`で別々のURLを設定できる。
リモートのより詳しい情報を取得するには`$ git remote show <リモート名>`を利用する。
```
$ git remote show origin
```

##  リモートリポジトリの複数登録
リモートリポジトリを複数追加する。
```
$ git remote add <ショートカット名（任意のリモート名）> <リモートリポジトリURL>
```
こうすることで新しいリモートリポジトリを任意のショートカット名で登録することができる。
できたら`git remote`コマンドで確認してみよう。
登録できていることが確認できたら、以下のようにショートカット名から別のリモートにプッシュができる。

```
$ git push <ショートカット名（任意）>
```

##  リモートから情報を取得（フェッチ[fetch]）する
GitHub上でCreate new fileをし、コミットする。この時GitHub（リモートリポジトリ）上では新しいファイルが存在するが、ローカルには存在していない状態になっている。
リモートリポジトリからローカルリポジトリに情報を取得してくるには`git fetch <リモート名>`コマンドを使う。
```
$ git fetch origin
```
これだけでは自分の作業場（ワークツリー）には反映されていない。ローカルリポジトリの`remotes/リモート/ブランチ`というリモートブランチに保存される。
```
$ git branch -a
* master
  remotes/origin/master //リモートリポジトリから取得した情報が格納される
```
現在ある全てのをブランチ表示させる。
フェッチされた内容を確認するため、`remotes/origin/master`へワークツリーを切り替える。
```
$ git checkout remotes/origin/master  //ワークツリーの切り替え
```
ブランチを切り替えたら、`ls`でファイル一覧を確認する。先ほどリモートリポジトリで作成したファイルを取得している。
ではmasterブランチへ戻って再度`ls`と入力してみよう。ワークツリーでもあるmasterブランチにまだファイルが反映されていないことが分かる。
最後にフェッチでリモートリポジトリから取得した内容をmasterブランチへ反映させる。このことをマージと言う。
```
$ git merge origin/master
```
以上でoriginリポジトリのmasterブランチの内容を自分のワークツリーに統合させることができる。
最後にもう一度`ls`で確認してみよう。リモートリポジトリで作成したファイルがワークツリー上に存在している。

## リモートから情報を取得してマージする（プル[pull]）
`fetch`とは別に`$ git pull <リモート名> <ブランチ名>`コマンドを使ってもリモートリポジトリから情報を取得できる。
```
$ git pull origin master
```
これは下記コマンドと同じことである。
```
$ git fetch origin master
$ git merge origin/master
```
つまり`pull`を使うことによって、一気にリモートリポジトリからワークツリーまで情報を取得できるのさ(/・ω・)/
先ほどと同じようにリモートリポジトリ上で情報を更新して、pullを使ってみよう。

##fetchとpullの使い分け
pullを実行すると、リモートリポジトリの内容のマージが自動的に行われてしまいます。しかし、単にリモートリポジトリの内容を確認したいだけの時はマージをしたくない場合もあります。そのような時はfetchを使用します。

## リモートの変更・削除
以前
```
$ git remote add <ショートカット名（任意のリモート名）> <リモートリポジトリURL>
```
で追加したリモートの名前の変更、削除を行ってみよう。
`git remote`コマンドで今あるリモートを確認しよう。リモートの名前を変更したい場合は`git remote rename <旧リモート名> <新リモート名>`とする。
不要になったリモートの削除は`git remote rm <リモート名>`とすればよい。
※リモートリポジトリから削除されるわけではないのでご安心を( *´艸｀)

##  ブランチとは
並行して複数機能を開発するためにあるのがブランチ。
masterブランチ（大元）から作業場を切り出し（ブランチの分岐）をし、それぞれが各機能の開発を行う。その後masterへマージすることで、複数人の変更が自分の作業に影響を及ぼすことなく、開発ができる。
```
            ブランチB
            （開発B）
    _____________________
    |                    ↓
---〇---------〇---------〇---> master
    |_________↑
      ブランチA
      （開発A）
```

##  ブランチの仕組み
まずコミットをすることによってその時のファイルのスナップショットが記録される。またコミットファイルには前のコミット情報であるparentの情報があるため、コミット履歴をたどることができる。
```
    コミット1             コミット2              コミット3
[コミットファイル1]<---[コミットファイル2]<---[コミットファイル3]
       ↓                       ↓                     ↓
[スナップショット1]    [スナップショット2]     [スナップショット3]
```
ブランチはこのコミットを指したポイントである。
```
                                                          {master(ブランチ)}<--{HEAD}
                                                            __/
    コミット1             コミット2              コミット3   ↓
[コミットファイル1]<---[コミットファイル2]<---[コミットファイル3]
       ↓                       ↓                     ↓
[スナップショット1]    [スナップショット2]     [スナップショット3]
```
HEADは今自分が作業しているブランチを指しているポインタとなる。
では次にコミット3の状態から新しくfeatureブランチを切った時の動きを見てみようぜ(^_-)-☆
```
      {master}
          ↓
  [コミットファイル3]
          ↑
      {feature}
```
まず自分がmasterブランチにいる状態で変更をコミットする（コミット4）
```
          {master}<--{HEAD}
              ↓
      [コミットファイル4]
           __/
          ↓
  [コミットファイル3]
          ↑
      {feature}
```
現時点ではmasterブランチはコミット4で作成されたコミットファイル4を指し、featureブランチはコミットファイル3を指している。
次にブランチをfeatureに切り替えてコミット5、コミット6をしてみる。
```
          {master}
              ↓
        [コミットファイル4]
            __/
          ↓
  [コミットファイル3]
          ↑__
              \
        [コミットファイル5]<---[コミットファイル6]
                                      ↑
                                  {feature}<--{HEAD}
```
こうしてそれぞれのブランチはコミットされる毎に指すコミットファイルが変わっていく。

##  ブランチとHEADの中身
上記の場合、masterブランチの中身にはmasterファイルがあり、その中にはコミットファイル4のコミットファイル名（コミットID）が記載されている。同じようにfeatureブランチの中身にはfeatureファイルがあり、コミットファイル5のコミットファイル名が記載されている。
HEADはHEADというファイルがあり、ref:featureと記載されている。つまりはfeatureブランチを参照しているということである。
また、これらのmaster、feature、HEADファイルはリポジトリ（.git/）の下に記録されている。



# 備考
##  Gitコマンドメモ
- リポジトリの削除
```
 rm -rf .git
```
- 変更したファイルの状態確認（ワークツリーとステージの比較、ステージとリポジトリの比較）
```
git status
```
- ステージング前のファイルの変更点確認（ワークツリーとステージの比較）
```
git diff <ファイル名>
```
- ステージングされたファイルの変更点確認（ステージとリポジトリの比較）
```
git diff --staged
```  
- 変更履歴の確認
```
git log
git log --oneline       //一行で表示
git log -p <ファイル名>  //ファイルの変更差分を表示する
git log -n <コミット数>  //表示するコミット数を制限する
```
- リポジトリとワークツリーからファイル、ディレクトリの削除
```
git rm <ファイル名>
git rm -r <ディレクトリ名>
```
- リポジトリからのみファイルの削除（ワークツリーには残る）
```
git rm --cached <ファイル名>
```
- ファイルの移動（ファイル名の変更）
```
git mv <旧ファイル名> <新ファイル名>
```
- リモートリポジトリからコピーの作成
```
git clone <リポジトリ名>
```
- originというショートカットでurlのリモートリポジトリを登録する
```
git remote add origin <リモートリポジトリのURL>
```
- ローカルリポジトリの内容をリモートリポジトリに登録する
```
git push <リモート名> <ブランチ名>
```
- 「.gitignore」ファイル内にバージョン管理したくないファイル名を記載することで、そのファイルを無視できる
- ファイルへの変更を取り消す
```
git checkout -- <ファイル名>     //ワークツリーのファイルをステージから取得し反映させる
git checkout -- <ディレクトリ名> //ワークツリーのディレクトリをステージから取得し反映させる
git checkout -- .               //全変更を取り消す
```
- ステージした変更の取り消し
```
git reset HEAD <ファイル名>  //リポジトリから直前のコミットの情報を取得し、ステージの内容を上書きする
git reset HEAD <ディレクトリ名>
git reset HEAD <ファイル名>
```
- 直前のコミットをやり直す
```
git commit --amend  //現在のステージの内容で、直前のコミットを上書きする ※push後には使ってはいけない
```
